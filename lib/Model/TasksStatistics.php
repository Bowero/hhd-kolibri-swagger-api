<?php
/**
 * TasksStatistics
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Web API Swagger specification Kolibri24 API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 4.1.778.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.17
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * TasksStatistics Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TasksStatistics implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'TasksStatistics';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'completed_count' => 'int',
        'expired_count' => 'int',
        'expires_after_next_week_count' => 'int',
        'expires_this_week_count' => 'int',
        'expires_next_week_count' => 'int',
        'expires_today_count' => 'int',
        'expires_tomorrow_count' => 'int',
        'no_end_date_count' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'completed_count' => 'int32',
        'expired_count' => 'int32',
        'expires_after_next_week_count' => 'int32',
        'expires_this_week_count' => 'int32',
        'expires_next_week_count' => 'int32',
        'expires_today_count' => 'int32',
        'expires_tomorrow_count' => 'int32',
        'no_end_date_count' => 'int32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'completed_count' => 'completedCount',
        'expired_count' => 'expiredCount',
        'expires_after_next_week_count' => 'expiresAfterNextWeekCount',
        'expires_this_week_count' => 'expiresThisWeekCount',
        'expires_next_week_count' => 'expiresNextWeekCount',
        'expires_today_count' => 'expiresTodayCount',
        'expires_tomorrow_count' => 'expiresTomorrowCount',
        'no_end_date_count' => 'noEndDateCount'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'completed_count' => 'setCompletedCount',
        'expired_count' => 'setExpiredCount',
        'expires_after_next_week_count' => 'setExpiresAfterNextWeekCount',
        'expires_this_week_count' => 'setExpiresThisWeekCount',
        'expires_next_week_count' => 'setExpiresNextWeekCount',
        'expires_today_count' => 'setExpiresTodayCount',
        'expires_tomorrow_count' => 'setExpiresTomorrowCount',
        'no_end_date_count' => 'setNoEndDateCount'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'completed_count' => 'getCompletedCount',
        'expired_count' => 'getExpiredCount',
        'expires_after_next_week_count' => 'getExpiresAfterNextWeekCount',
        'expires_this_week_count' => 'getExpiresThisWeekCount',
        'expires_next_week_count' => 'getExpiresNextWeekCount',
        'expires_today_count' => 'getExpiresTodayCount',
        'expires_tomorrow_count' => 'getExpiresTomorrowCount',
        'no_end_date_count' => 'getNoEndDateCount'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['completed_count'] = isset($data['completed_count']) ? $data['completed_count'] : null;
        $this->container['expired_count'] = isset($data['expired_count']) ? $data['expired_count'] : null;
        $this->container['expires_after_next_week_count'] = isset($data['expires_after_next_week_count']) ? $data['expires_after_next_week_count'] : null;
        $this->container['expires_this_week_count'] = isset($data['expires_this_week_count']) ? $data['expires_this_week_count'] : null;
        $this->container['expires_next_week_count'] = isset($data['expires_next_week_count']) ? $data['expires_next_week_count'] : null;
        $this->container['expires_today_count'] = isset($data['expires_today_count']) ? $data['expires_today_count'] : null;
        $this->container['expires_tomorrow_count'] = isset($data['expires_tomorrow_count']) ? $data['expires_tomorrow_count'] : null;
        $this->container['no_end_date_count'] = isset($data['no_end_date_count']) ? $data['no_end_date_count'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = parent::listInvalidProperties();

        if ($this->container['completed_count'] === null) {
            $invalidProperties[] = "'completed_count' can't be null";
        }
        if ($this->container['expired_count'] === null) {
            $invalidProperties[] = "'expired_count' can't be null";
        }
        if ($this->container['expires_after_next_week_count'] === null) {
            $invalidProperties[] = "'expires_after_next_week_count' can't be null";
        }
        if ($this->container['expires_this_week_count'] === null) {
            $invalidProperties[] = "'expires_this_week_count' can't be null";
        }
        if ($this->container['expires_next_week_count'] === null) {
            $invalidProperties[] = "'expires_next_week_count' can't be null";
        }
        if ($this->container['expires_today_count'] === null) {
            $invalidProperties[] = "'expires_today_count' can't be null";
        }
        if ($this->container['expires_tomorrow_count'] === null) {
            $invalidProperties[] = "'expires_tomorrow_count' can't be null";
        }
        if ($this->container['no_end_date_count'] === null) {
            $invalidProperties[] = "'no_end_date_count' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets completed_count
     *
     * @return int
     */
    public function getCompletedCount()
    {
        return $this->container['completed_count'];
    }

    /**
     * Sets completed_count
     *
     * @param int $completed_count completed_count
     *
     * @return $this
     */
    public function setCompletedCount($completed_count)
    {
        $this->container['completed_count'] = $completed_count;

        return $this;
    }

    /**
     * Gets expired_count
     *
     * @return int
     */
    public function getExpiredCount()
    {
        return $this->container['expired_count'];
    }

    /**
     * Sets expired_count
     *
     * @param int $expired_count expired_count
     *
     * @return $this
     */
    public function setExpiredCount($expired_count)
    {
        $this->container['expired_count'] = $expired_count;

        return $this;
    }

    /**
     * Gets expires_after_next_week_count
     *
     * @return int
     */
    public function getExpiresAfterNextWeekCount()
    {
        return $this->container['expires_after_next_week_count'];
    }

    /**
     * Sets expires_after_next_week_count
     *
     * @param int $expires_after_next_week_count The number op open (not completed and not cancelled) tasks with an expiration date set to a date after two weeks.
     *
     * @return $this
     */
    public function setExpiresAfterNextWeekCount($expires_after_next_week_count)
    {
        $this->container['expires_after_next_week_count'] = $expires_after_next_week_count;

        return $this;
    }

    /**
     * Gets expires_this_week_count
     *
     * @return int
     */
    public function getExpiresThisWeekCount()
    {
        return $this->container['expires_this_week_count'];
    }

    /**
     * Sets expires_this_week_count
     *
     * @param int $expires_this_week_count The number op open (not completed and not cancelled) tasks with an expiration date set to a date in the current week.
     *
     * @return $this
     */
    public function setExpiresThisWeekCount($expires_this_week_count)
    {
        $this->container['expires_this_week_count'] = $expires_this_week_count;

        return $this;
    }

    /**
     * Gets expires_next_week_count
     *
     * @return int
     */
    public function getExpiresNextWeekCount()
    {
        return $this->container['expires_next_week_count'];
    }

    /**
     * Sets expires_next_week_count
     *
     * @param int $expires_next_week_count The number op open (not completed and not cancelled) tasks with an expiration date set to a date in the next week.
     *
     * @return $this
     */
    public function setExpiresNextWeekCount($expires_next_week_count)
    {
        $this->container['expires_next_week_count'] = $expires_next_week_count;

        return $this;
    }

    /**
     * Gets expires_today_count
     *
     * @return int
     */
    public function getExpiresTodayCount()
    {
        return $this->container['expires_today_count'];
    }

    /**
     * Sets expires_today_count
     *
     * @param int $expires_today_count The number op open (not completed and not cancelled) tasks with an expiration date set to today.
     *
     * @return $this
     */
    public function setExpiresTodayCount($expires_today_count)
    {
        $this->container['expires_today_count'] = $expires_today_count;

        return $this;
    }

    /**
     * Gets expires_tomorrow_count
     *
     * @return int
     */
    public function getExpiresTomorrowCount()
    {
        return $this->container['expires_tomorrow_count'];
    }

    /**
     * Sets expires_tomorrow_count
     *
     * @param int $expires_tomorrow_count The number op open (not completed and not cancelled) tasks with an expiration date set to tomorrow, but only in case tomorrow is in the current week. So on Sundays ExpiresTomorrowCount will always be 0.
     *
     * @return $this
     */
    public function setExpiresTomorrowCount($expires_tomorrow_count)
    {
        $this->container['expires_tomorrow_count'] = $expires_tomorrow_count;

        return $this;
    }

    /**
     * Gets no_end_date_count
     *
     * @return int
     */
    public function getNoEndDateCount()
    {
        return $this->container['no_end_date_count'];
    }

    /**
     * Sets no_end_date_count
     *
     * @param int $no_end_date_count no_end_date_count
     *
     * @return $this
     */
    public function setNoEndDateCount($no_end_date_count)
    {
        $this->container['no_end_date_count'] = $no_end_date_count;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


